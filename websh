#!/bin/bash

readonly TMPDIR="$(mktemp -d)"
IMG_SAVEDIR="$TMPDIR"
INPUT_IMAGES=()

function usage(){
  cat << 'USG' >&2
websh

Description:
  websh(https://websh.jiro4989.com) on Bash

Usage:
  $ websh <cmd> [-d IMG_SAVEDIR ] [ -i INPUT_IMAGE ] [-h]

  $ echo <cmd> | websh

Option:
  -d IMG_SAVEDIR	Set a dir saving output image(s) (default: $TMPDIR)
  -i INPUT_IMAGE	Specify the input image path (max: 4)
  -h            	Show help and exit

Requirement:
  jq, curl, GNU sed
USG
  exit 0
}

function check_jq(){
  which jq > /dev/null 2> /dev/null || {
    echo 'Please install jq command' >&2 && exit 1
  }
}

function check_curl(){
  which curl > /dev/null 2> /dev/null || {
    echo 'Please install curl command' >&2 && exit 1
  }
}

function check_sed(){
  sed --help |& grep -q '\-z' || {
    echo 'please install GNU sed command' >&2 && exit 1
  }
}

function img_to_base64(){
  for i in "$@"
  {
    base64 < "$i" | sed -z 's/\n//g;s/.*/&\n/'
  } | xargs
}

function mk_req(){
  local code arr str
  code="$*"
  arr=(\"%s\" \"%s\" \"%s\" \"%s\")
  str="$(echo "{\"code\":\"%s\",\"images\":[${arr[*]:0:${#INPUT_IMAGES[*]}}]}" | tr \  ,)"

  # shellcheck disable=SC2059
  if [ "${#INPUT_IMAGES[*]}" -eq 0 ]
  then
    printf "$str" "$code"
  else
    # shellcheck disable=SC2046,SC2086
    printf "$str" "$code" $(img_to_base64 ${INPUT_IMAGES[*]})
  fi
}

function websh_post(){
  curl -s https://websh.jiro4989.com/api/shellgei \
       -X POST -H "Content-Type: application/json" \
       -d "$(mk_req "$@")"
}

function get_req(){
  echo -e "$(cat - | jq -r '
    [
      "\\e[42mstdout:\\e[m",
      .stdout,
      "\\e[41mstderr:\\e[m",
      .stderr,
      "\\e[45mimages:\\e[m",
      (if .images == [] then "(none)" else (
        .images[] | [.image, (.filesize|tostring), .format] | join(" ")
      ) end),
      "\n\\e[30;47m[status: " + (.status|tostring) +
      ", time: " + (.elapsed_time|sub("milsec";" ms")) + "]\\e[m"
    ] | join("\n")
  ')"
}

function base64_to_img(){
  if [[ -z "$(sed -nrz 's/.*\x1b\[45mimages:\x1b\[m\n\((none)\).*/\1/p' "${TMPDIR}/res")" ]]
  then
    (
      sed -rnz 's/.*(\x1b\[45mimages:\x1b\[m\n)(.*)(\n\x1b\[30;47m).*/\2/p' "${TMPDIR}/res" |
      while read -r a b c;do
        local i
        local savepath="$IMG_SAVEDIR/$((i++)).$c"
        echo "$a" | base64 -d > "$savepath"
        echo "(path: ${savepath}, size: ${b} byte)"
      done
    ) > "${TMPDIR}/a"
    sed -rz "s_(.*)(\x1b\[45mimages:\x1b\[m\n)(.*)(\n\x1b\[30;47m)(.*)_\1\2$(sed -z 's/\n/\\n/g' "${TMPDIR}/a")\4\5_" "$TMPDIR/res"
  else
    cat "${TMPDIR}/res"
  fi
}

function main(){
  {
    [ $# -ne 0 ] || [ -p /dev/stdin ]
  } || usage
  check_jq && check_curl && check_sed

  local args
  args="$(getopt i:d:h "$@")" || {
    echo "Unable to parse options" >&2 && usage
  }

  # shellcheck disable=SC2086
  set -- $args
  for OPT in "$@"
  do
    case "$OPT" in
        -i) if [ -f "$2" ]
            then
              INPUT_IMAGES+=("$2")
              shift 2
            else
              usage
            fi
            ;;
        -d) if [ -d "$2" ]
            then
              IMG_SAVEDIR="$2"
              shift 2
            else
              echo "${IMG_SAVEDIR} is not exist." >&2 && usage
            fi
            ;;
        -h) usage
            ;;
        --) shift
            break
            ;;
    esac
  done

  if [ "${#INPUT_IMAGES[*]}" -gt 4 ]
  then
    echo 'Up to 4 input images.' >&2 && usage
  fi

  echo -e '\e[44minput:\e[m'
  if [ -p /dev/stdin ]
  then
    cp /dev/stdin "${TMPDIR}/stdin"
    cat "${TMPDIR}/stdin"
    echo -ne '\n\e[5mwait!\e[m\r'
    websh_post "$(cat "${TMPDIR}/stdin")" | get_req > "${TMPDIR}/res"
  else
    echo "$@"
    echo -ne '\n\e[5mwait!\e[m\r'
    websh_post "$@" | get_req > "${TMPDIR}/res"
  fi
  base64_to_img
  rm -rf "${TMPDIR}/a" "${TMPDIR}/res" "${TMPDIR}/stdin"
}

main "$@"
exit "$?"
